A.

- Additions:
  This procedure performs `n` additions to increment the loop variable,
  and another `n` to compute the result. We therefore have `2*n` addition
  operations in total.

- Multiplications:
  Two multiplications are performed per loop; therefore, we have a total
  of 2*n multiplication operations.

B.

Old thoughts:

The measured CPE matches the latency of the floating-point
multiplication operation on the reference machine. One might expect
that, since there are two floating-point multiplications per iteration,
the CPE would be two times as much; however, the reference machine's
capacity for this instruction is two, so these multiplications can be
performed simultaneously.

Newer thoughts:

I don't understand how this is possible. The measured CPE should be at
best 8.00, similarly to practice problem 5.6, because the critical path
should have at least one floating-point addition (L = 3) and one
floating-point multiplication (L = 5) operation, not to mention the load
operation. The book's solution doesn't make any sense, either; it seems
to ignore the `a[i] * xpwr` code. Without the assembly code they used,
it's difficult to analyse this any further. With it, I might be able to
draw the data-flow graph and understand what's going on. I can sort of
see what they're talking about, but I'd like to prove it to myself.

Newest thoughts:

From the graphical representation (below) of the the assembly code
generated by GCC with optimisation level 1 (see pp5.5.c and pp5.5.s), we
can see that there is a critical path through register %xmm1 containing
a single `mul` instruction. It is a floating-point multiplication which
corresponds with the `xpwr = x*xpwr;` statement in the compiled
procedure. It is this path that bottlenecks the performance to the
empirically measured CPE of 5.00, which is the latency of the
floating-point mul instruction.

%rax | %rdx | %xmm0 | %xmm1 | %xmm2 | %xmm3
  |`-----|------|-------|---------------|--> load      movsd (%rax), %xmm2 ; t <- *a
  |      |      |       |        ,------|----'
   `-----|------|-------|-------|-------|--> add       addq  $8, %rax      ; a <- 8 + a
   ,-----|------|-------|-------|-------|----'
  |      |      |       |`------|-------|--> mul       mulsd %xmm1, %xmm2  ; t <- xpwr*t
  |      |      |       |        `------|----^ |
  |      |      |       |        ,------|------'
  |      |      |       |       |       |`-> mul       mulsd %xmm3, %xmm1  ; xpwr <- x*xpwr
  |      |      |        `------|-------|----^ |
  |      |      |        ,------|-------|------'
  |      |      |       |       |`------|--> add       addsd %xmm2, %xmm0  ; result <- t + result
  |      |       `------|-------|-------|----^ |
  |      |       ,------|-------|-------|------'
  |      |`-----|-------|-------|-------|--> cmp -,    cmpq  %rdx, %rax    ; Compare degree:a
  |`-----|------|-------|-------|-------|----^    v
  v      v      v       v       v       v    jne loop  jne	 .L3           ; Jump if !=
%rax | %rdx | %xmm0 | %xmm1 | %xmm2 | %xmm3
